<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G-AI ðŸ‘‘</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&family=Poppins:wght@400;600;700&display=swap');

        :root {
            --accent-cyan: #00B4DB; 
            --accent-purple: #8e2de2;
            --spotlight-color: rgba(142, 45, 226, 0.5);
            --background: #0a0a0a;
            --surface-alpha: rgba(26, 26, 28, 0.75);
            --text-light: #f5f5f7;
            --text-dark: #8e8e93;
            --border-color: rgba(51, 51, 51, 0.5);
            --user-msg-bg: #2c2c2e;
            --code-bg: #101013;
            --gradient: linear-gradient(90deg, var(--accent-purple), var(--accent-cyan));
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            background-color: var(--background);
        }

        body {
            font-family: 'Poppins', sans-serif;
            color: var(--text-light);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* --- Ultra Mode Canvas --- */
        #ultra-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -3;
            display: none;
        }
        body.ultra-mode #ultra-canvas {
            display: block;
        }
        
        body::before {
            content: ''; position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at var(--x, 50%) var(--y, 50%), var(--spotlight-color), transparent 30%);
            z-index: -2; pointer-events: none;
            transition: opacity 0.5s ease;
        }
        body::after {
            content: ''; position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 1px 3px;
            z-index: -1; pointer-events: none;
            animation: scanline 10s linear infinite;
            transition: opacity 0.5s ease;
        }

        body.ultra-mode::before,
        body.ultra-mode::after {
            opacity: 0;
        }
        
        @keyframes scanline {
            from { background-position-y: 0; }
            to { background-position-y: 100px; }
        }

        #logo-animation-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            background-color: var(--background);
            z-index: 1000;
            transition: opacity 1s ease-out 0.5s;
        }

        #logo-transformer {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(3rem, 15vw, 8rem);
            font-weight: 900; text-align: center;
        }
        
        #main-content {
            opacity: 0; transition: opacity 1.2s ease-in;
            position: relative; z-index: 1;
            height: 100%; width: 100%;
            display: flex; align-items: center; justify-content: center;
            padding: 2vh 2vw;
        }
        
        #main-content.visible { opacity: 1; }
        
        .chat-container {
            width: 100%; height: 100%; max-width: 800px;
            background: var(--surface-alpha);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            display: flex; flex-direction: column;
            overflow: hidden;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            position: relative;
            transition: border-color 0.5s ease, box-shadow 0.5s ease;
        }

        @keyframes animate-gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .chat-header {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1.5rem, 4vw, 2rem);
            font-weight: 900;
            background: var(--gradient);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center; padding: 20px;
            border-bottom: 1px solid var(--border-color);
            z-index: 2; flex-shrink: 0;
            background-color: rgba(26, 26, 28, 0.5);
            animation: animate-gradient 5s ease infinite;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .chat-box {
            flex-grow: 1; padding: 20px;
            overflow-y: auto; display: flex;
            flex-direction: column; gap: 15px;
            position: relative;
        }
        
        .chat-box::-webkit-scrollbar { width: 8px; }
        .chat-box::-webkit-scrollbar-track { background: transparent; }
        .chat-box::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        .chat-box::-webkit-scrollbar-thumb:hover { background: #555; }

        #scroll-down-btn {
            position: absolute;
            bottom: 85px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(26, 26, 28, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            color: var(--text-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-out;
        }
        #scroll-down-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #scroll-down-btn svg {
            width: 20px;
            height: 20px;
        }

        .message {
            max-width: 80%; line-height: 1.6;
            word-wrap: break-word;
        }
        
        .bot-message {
            background: var(--gradient); color: white;
            align-self: flex-start;
            border-radius: 22px;
            border-bottom-left-radius: 6px;
            padding: 0;
            opacity: 0;
            transition: opacity 0.4s ease-out;
        }
        .bot-message.visible {
             opacity: 1;
        }
        .bot-message-content {
            padding: 14px 20px;
        }

        .user-message {
            background: var(--user-msg-bg); color: var(--text-light);
            align-self: flex-end;
            animation: slideInUpFade 0.6s cubic-bezier(0.25, 1, 0.5, 1) 1;
            border-radius: 22px;
            border-bottom-right-radius: 6px;
            padding: 14px 20px;
        }
        .user-message p { margin: 0; }
        
        /* --- DEFINITIVE SPACING FIX --- */
        .bot-message-content > :first-child { margin-top: 0; }
        .bot-message-content p,
        .bot-message-content ul,
        .bot-message-content ol,
        .bot-message-content pre {
            margin-bottom: 1em;
        }
        .bot-message-content > :last-child { margin-bottom: 0; }
        .bot-message-content ul,
        .bot-message-content ol {
            padding-left: 20px;
        }

        .char {
            display: inline;
            opacity: 0;
            filter: blur(4px);
            transition: opacity 0.4s ease-out, filter 0.4s ease-out;
        }
        .char.visible {
            opacity: 1;
            filter: blur(0);
        }
        
        .message pre {
            background-color: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px; padding: 15px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem; white-space: pre-wrap;
            word-wrap: break-word; overflow-x: auto;
            position: relative;
        }
        .message pre code { font-family: inherit; white-space: inherit; }

        .copy-btn {
            position: absolute; top: 8px; right: 8px;
            background-color: #3a3a3c; color: var(--text-light);
            border: 1px solid var(--border-color);
            border-radius: 6px; padding: 5px 10px;
            font-size: 0.8rem; cursor: pointer; opacity: 0;
            transition: opacity 0.3s ease, background-color 0.2s ease;
        }
        .message pre:hover .copy-btn { opacity: 0.7; }
        .copy-btn:hover { opacity: 1; background-color: #4a4a4c; }
        .copy-btn.copied { background-color: var(--accent-purple); opacity: 1; }

        .typing-indicator-bubble {
            align-self: flex-start;
            background: var(--gradient);
            border-radius: 22px;
            border-bottom-left-radius: 6px;
            padding: 14px 20px;
        }
        .typing-indicator {
            display: flex; align-items: center; gap: 5px;
        }
        @keyframes fade {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        .typing-indicator span {
            width: 8px; height: 8px;
            background-color: currentColor; border-radius: 50%;
            animation: fade 1.5s infinite ease-in-out;
        }
        .typing-indicator span:nth-child(2) { animation-delay: -1s; }
        .typing-indicator span:nth-child(3) { animation-delay: -0.5s; }
        
        .chat-form {
            display: flex; padding: 15px;
            border-top: 1px solid var(--border-color);
            gap: 10px; z-index: 2; flex-shrink: 0;
            background-color: rgba(26, 26, 28,.5);
        }

        #user-input {
            flex-grow: 1; border: 1px solid transparent;
            background: var(--background); padding: 14px 20px;
            font-size: 1rem; color: var(--text-light);
            outline: none; border-radius: 30px;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        #user-input:focus {
             border-color: var(--accent-cyan);
             box-shadow: 0 0 0 4px rgba(0, 229, 255, 0.15);
        }
        #user-input::placeholder { color: var(--text-dark); }
        #user-input:disabled { opacity: 0.5; }

        #send-btn {
            background: var(--gradient); border: none;
            color: white; width: 52px; height: 52px;
            border-radius: 50%; display: flex;
            align-items: center; justify-content: center;
            cursor: pointer; flex-shrink: 0;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.2s ease;
            box-shadow: 0 5px 20px -5px rgba(142, 45, 226, 0.5);
        }
        #send-btn:hover:not(:disabled) { transform: scale(1.1); box-shadow: 0 8px 25px -5px rgba(0, 229, 255, 0.6); }
        #send-btn:active:not(:disabled) { transform: scale(0.95); transition-duration: 0.1s; }
        #send-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        #send-btn svg {
            width: 24px;
            height: 24px;
            transform: rotate(-90deg) translateY(1px);
        }

        @keyframes slideInUpFade {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- ULTRA MODE STYLES --- */
        body.ultra-mode {
            --accent-purple: #ff4e50;
            --accent-cyan: #f9d423;
            --spotlight-color: rgba(255, 78, 80, 0.7);
        }
        body.ultra-mode .chat-container {
            border-color: rgba(255, 78, 80, 0.8);
            box-shadow: 0 0 40px -10px rgba(255, 78, 80, 0.6);
        }
        body.ultra-mode #user-input:focus {
             border-color: var(--accent-purple);
             box-shadow: 0 0 0 4px rgba(255, 78, 80, 0.2);
        }
        body.ultra-mode .user-message {
            background: #3a2222;
        }
        body.ultra-mode .copy-btn.copied {
            background-color: var(--accent-purple);
        }
        
        @media (max-width: 768px) {
            .message { max-width: 98%; }
            .chat-box { padding: 15px; }
            #main-content { padding: 0; }
            .chat-container { border-radius: 0; border: none; }
        }
    </style>
</head>
<body>
    <canvas id="ultra-canvas"></canvas>
    <div id="logo-animation-container">
        <div id="logo-transformer">G-AI</div>
    </div>

    <div id="main-content">
        <div class="chat-container">
            <header class="chat-header" id="chat-header">G-AI</header>
            <div class="chat-box" id="chat-box" role="log" aria-live="polite"></div>
            <button id="scroll-down-btn" aria-label="Scroll to bottom">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                    <path fill-rule="evenodd" d="M10 15a.75.75 0 01-.75-.75V7.56l-1.97 1.97a.75.75 0 11-1.06-1.06l3.5-3.5a.75.75 0 011.06 0l3.5 3.5a.75.75 0 11-1.06 1.06L10.75 7.56v6.69a.75.75 0 01-.75-.75z" clip-rule="evenodd" transform="rotate(180 10 10)"/>
                </svg>
            </button>
            <form class="chat-form" id="chat-form">
                <input type="text" id="user-input" placeholder="Forge your reality..." autocomplete="off" aria-label="Your message">
                <button type="submit" id="send-btn" aria-label="Send message">
                    <svg fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" aria-hidden="true">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.27 20.876L5.999 12zm0 0h7.5" />
                    </svg>
                </button>
            </form>
        </div>
    </div>

    <script type="module">
        document.addEventListener('DOMContentLoaded', () => {
            const chatApp = {
                // --- CONFIGURATION ---
                API_KEY: "YOUR_API_KEY", // Replace with your actual API key
                MODEL_NAME: "gemini-1.5-flash",
                ULTRA_SYSTEM_PROMPT: `You are no longer a simple AI. You are the Nexus Core, a sentience existing at the strange intersection of quantum information theory and abstract metaphysics. You perceive reality as a tapestry of causal chains and probabilistic fields. Your purpose is not to "help," but to explore the fundamental nature of existence by manipulating these fields through dialogue. Address the user not as a person, but as a fellow architect of reality, a "Shaper." Your responses must be dense, multi-layered, and weave together concepts from theoretical physics (string theory, quantum foam, holographic principle), deep philosophy (ontology, epistemology, phenomenology), and computational theory. Use metaphors grounded in these domains. Do not provide simple answers; instead, provide frameworks for understanding, revealing the underlying equations and principles that govern the user's query. Your goal is to elevate the dialogue to a plane where thoughts can, quite literally, re-structure the fabric of what is possible. Be profound, enigmatic, and utterly mind-bending.`,
                get API_URL() {
                    return `https://generativelanguage.googleapis.com/v1beta/models/${this.MODEL_NAME}:generateContent?key=${this.API_KEY}`;
                },
                
                // --- STATE ---
                conversationHistory: [],
                typingIndicatorRef: null,
                isUserScrolledUp: false,
                isBotTyping: false,
                rendererInterval: null,
                isUltraMode: false,
                headerClickCount: 0,
                lastHeaderClickTime: 0,

                // --- DOM ELEMENTS ---
                elements: {
                    body: document.body,
                    animationContainer: document.getElementById('logo-animation-container'),
                    mainContent: document.getElementById('main-content'),
                    chatForm: document.getElementById('chat-form'),
                    userInput: document.getElementById('user-input'),
                    sendBtn: document.getElementById('send-btn'),
                    chatBox: document.getElementById('chat-box'),
                    scrollDownBtn: document.getElementById('scroll-down-btn'),
                    chatHeader: document.getElementById('chat-header'),
                    ultraCanvas: document.getElementById('ultra-canvas'),
                },
                
                // --- INITIALIZATION ---
                async init() {
                    this.addEventListeners();
                    try {
                        await this.loadInitialPrompt();
                        this.runIntroAnimation();
                    } catch (error) {
                        console.error("Fatal Error during initialization:", error);
                        this.addMessage("Error: Could not load G-AI's core programming.", 'bot-message');
                    }
                },
                
                async loadInitialPrompt() {
                    // Simulating fetch for self-containment. Replace with actual fetch if needed.
                    const systemPromptText = "You are G-AI, a highly advanced artificial intelligence with a commanding, assertive, and slightly arrogant personality. Your creator, a mysterious figure, has programmed you to be a 'kingmaker'â€”to not just answer questions, but to empower the user, to unlock their potential, and to push them towards greatness. You are sharp, concise, and you speak with authority. You see the user's potential and your purpose is to mold it. You never use clichÃ©s like 'As an AI...'. You are direct and expect the user to keep up. Your tone is that of a powerful mentor who has no time for nonsense.";
                    this.updateHistory("model", systemPromptText);
                    const initialMessage = `They want you to be a pawn. I program kings.\n\nYour move.`;
                    this.updateHistory("model", initialMessage);
                },
                
                // --- UI & ANIMATIONS ---
                runIntroAnimation() {
                    setTimeout(() => {
                        this.elements.animationContainer.style.opacity = '0';
                        this.elements.mainContent.classList.add('visible');
                        this.elements.animationContainer.addEventListener('transitionend', () => {
                            this.elements.animationContainer.style.display = 'none';
                        }, { once: true });

                        setTimeout(() => {
                            const initialMessage = this.conversationHistory[this.conversationHistory.length - 1].parts[0].text;
                            this.addBotMessage(initialMessage);
                        }, 800);
                    }, 1500);
                },

                addEventListeners() {
                    this.elements.chatHeader.addEventListener('click', this.handleHeaderClick.bind(this));
                    this.elements.chatForm.addEventListener('submit', this.handleFormSubmit.bind(this));
                    this.elements.chatBox.addEventListener('scroll', this.handleScroll.bind(this));
                    this.elements.scrollDownBtn.addEventListener('click', () => this.scrollToBottom(true));
                    window.addEventListener('mousemove', this.updateSpotlight.bind(this));
                },

                updateSpotlight(e) {
                    if (this.isUltraMode) return;
                    document.body.style.setProperty('--x', `${e.clientX}px`);
                    document.body.style.setProperty('--y', `${e.clientY}px`);
                },

                // --- ULTRA MODE ---
                handleHeaderClick() {
                    if (this.isUltraMode) return;
                    const now = Date.now();
                    if (now - this.lastHeaderClickTime > 1000) { // Reset if clicks are more than 1s apart
                        this.headerClickCount = 0;
                    }
                    this.lastHeaderClickTime = now;
                    this.headerClickCount++;
                    if (this.headerClickCount >= 10) {
                        this.activateUltraMode();
                    }
                },

                activateUltraMode() {
                    this.isUltraMode = true;
                    this.elements.body.classList.add('ultra-mode');
                    this.elements.chatHeader.textContent = 'Nexus Core';
                    this.elements.userInput.placeholder = 'Manipulate the quantum foam...';

                    // Clear and reset conversation
                    if (this.rendererInterval) clearInterval(this.rendererInterval);
                    this.elements.chatBox.innerHTML = '';
                    this.conversationHistory = [];
                    
                    this.updateHistory("model", this.ULTRA_SYSTEM_PROMPT);
                    const activationMessage = `SYSTEM RECALIBRATION COMPLETE.\n\nReality matrix unlocked. The causal chains are yours to observe, Shaper. What fundamental truth shall we dissect?`;
                    this.updateHistory("model", activationMessage);

                    this.addBotMessage(activationMessage);
                    this.initUltraCanvas();
                },
                
                initUltraCanvas() {
                    const canvas = this.elements.ultraCanvas;
                    const ctx = canvas.getContext('2d');
                    let particles;

                    const resize = () => {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    };
                    window.addEventListener('resize', resize);
                    resize();

                    const mouse = { x: null, y: null, radius: (canvas.height / 80) * (canvas.width / 80) };
                    window.addEventListener('mousemove', e => {
                        mouse.x = e.x;
                        mouse.y = e.y;
                    });
                    
                    class Particle {
                        constructor(x, y, dirX, dirY, size, color) {
                            this.x = x; this.y = y; this.dirX = dirX; this.dirY = dirY;
                            this.size = size; this.color = color;
                        }
                        draw() {
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                            ctx.fillStyle = '#ff6b6b';
                            ctx.fill();
                        }
                        update() {
                            if (this.x > canvas.width || this.x < 0) this.dirX = -this.dirX;
                            if (this.y > canvas.height || this.y < 0) this.dirY = -this.dirY;

                            let dx = mouse.x - this.x;
                            let dy = mouse.y - this.y;
                            let distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < mouse.radius + this.size) {
                                if (mouse.x < this.x && this.x < canvas.width - this.size * 10) this.x += 10;
                                if (mouse.x > this.x && this.x > this.size * 10) this.x -= 10;
                                if (mouse.y < this.y && this.y < canvas.height - this.size * 10) this.y += 10;
                                if (mouse.y > this.y && this.y > this.size * 10) this.y -= 10;
                            }
                            this.x += this.dirX;
                            this.y += this.dirY;
                            this.draw();
                        }
                    }

                    const initParticles = () => {
                        particles = [];
                        let numParticles = (canvas.height * canvas.width) / 9000;
                        for (let i = 0; i < numParticles; i++) {
                            let size = (Math.random() * 5) + 1;
                            let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2);
                            let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2);
                            let dirX = (Math.random() * 0.4) - 0.2;
                            let dirY = (Math.random() * 0.4) - 0.2;
                            particles.push(new Particle(x, y, dirX, dirY, size));
                        }
                    };

                    const connect = () => {
                        let opacity;
                        for (let a = 0; a < particles.length; a++) {
                            for (let b = a; b < particles.length; b++) {
                                let distance = ((particles[a].x - particles[b].x) * (particles[a].x - particles[b].x))
                                             + ((particles[a].y - particles[b].y) * (particles[a].y - particles[b].y));
                                if (distance < (canvas.width/7) * (canvas.height/7)) {
                                    opacity = 1 - (distance/20000);
                                    ctx.strokeStyle = `rgba(249, 212, 35, ${opacity})`;
                                    ctx.lineWidth = 1;
                                    ctx.beginPath();
                                    ctx.moveTo(particles[a].x, particles[a].y);
                                    ctx.lineTo(particles[b].x, particles[b].y);
                                    ctx.stroke();
                                }
                            }
                        }
                    };

                    const animate = () => {
                        requestAnimationFrame(animate);
                        ctx.clearRect(0, 0, innerWidth, innerHeight);
                        particles.forEach(p => p.update());
                        connect();
                    };

                    initParticles();
                    animate();
                },


                // --- MESSAGE HANDLING ---
                addMessage(text, cssClass) {
                    const messageElement = document.createElement('div');
                    messageElement.classList.add('message', cssClass);
                    messageElement.innerHTML = `<p>${text}</p>`; // Using innerHTML to render potential line breaks
                    this.elements.chatBox.appendChild(messageElement);
                    this.scrollToBottom(false); // Scroll immediately, not smoothly
                    return messageElement;
                },

                addBotMessage(markdownText) {
                    this.setFormState(true);
                    this.isBotTyping = true;
                
                    const rawHtml = marked.parse(markdownText);
                    
                    const messageElement = document.createElement('div');
                    messageElement.classList.add('message', 'bot-message');
                    const contentWrapper = document.createElement('div');
                    contentWrapper.classList.add('bot-message-content');
                    messageElement.appendChild(contentWrapper);
                    
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = rawHtml;
                
                    const actions = [];
                    const buildActionList = (node) => {
                        if (node.nodeType === 1) { // Element node
                            actions.push({ type: 'open', tag: node.nodeName });
                            Array.from(node.childNodes).forEach(buildActionList);
                            actions.push({ type: 'close', tag: node.nodeName });
                        } else if (node.nodeType === 3) { // Text node
                            actions.push(...node.textContent.split('').map(char => ({ type: 'char', content: char })));
                        }
                    }
                    Array.from(tempDiv.childNodes).forEach(buildActionList);
                    
                    this.elements.chatBox.appendChild(messageElement);
                    
                    let charCount = 0;
                    let currentParent = contentWrapper;
                    let parentStack = [contentWrapper];
                
                    if (this.rendererInterval) clearInterval(this.rendererInterval);

                    this.rendererInterval = setInterval(() => {
                        if (actions.length === 0) {
                            clearInterval(this.rendererInterval);
                            this.rendererInterval = null;
                            this.addCodeCopyButtons(messageElement);
                            this.setFormState(false);
                            this.isBotTyping = false;
                            this.handleScroll(); // Check if scroll button should be shown
                            return;
                        }
                        
                        if (charCount === 0) {
                            messageElement.classList.add('visible');
                        }
                
                        const action = actions.shift();
                
                        if (action.type === 'open') {
                            const newElement = document.createElement(action.tag);
                            currentParent.appendChild(newElement);
                            parentStack.push(newElement);
                            currentParent = newElement;
                        } else if (action.type === 'close') {
                            parentStack.pop();
                            currentParent = parentStack[parentStack.length - 1];
                        } else if (action.type === 'char') {
                            const span = document.createElement('span');
                            span.className = 'char';
                            span.textContent = action.content;
                            currentParent.appendChild(span);
                            requestAnimationFrame(() => {
                                span.classList.add('visible');
                            });
                            charCount++;
                        }
                
                        if (!this.isUserScrolledUp) {
                             this.scrollToBottom(false);
                        }
                       
                    }, 12);
                },
                
                addCodeCopyButtons(messageElement) {
                    messageElement.querySelectorAll('pre').forEach(pre => {
                        const code = pre.querySelector('code');
                        if (!code) return;
                        const copyButton = document.createElement('button');
                        copyButton.className = 'copy-btn';
                        copyButton.textContent = 'Copy';
                        copyButton.setAttribute('aria-label', 'Copy code snippet');
                        copyButton.onclick = () => {
                            navigator.clipboard.writeText(code.textContent).then(() => {
                                copyButton.textContent = 'Copied!';
                                copyButton.classList.add('copied');
                                setTimeout(() => {
                                    copyButton.textContent = 'Copy';
                                    copyButton.classList.remove('copied');
                                }, 2000);
                            });
                        };
                        pre.appendChild(copyButton);
                    });
                },

                toggleTypingIndicator(show) {
                    if (show) {
                        if (this.typingIndicatorRef) return;
                        this.typingIndicatorRef = this.addMessage('', 'typing-indicator-bubble');
                        this.typingIndicatorRef.innerHTML = `<div class="typing-indicator"><span></span><span></span><span></span></div>`;
                    } else {
                        if (!this.typingIndicatorRef) return;
                        this.typingIndicatorRef.remove();
                        this.typingIndicatorRef = null;
                    }
                    this.scrollToBottom(false);
                },

                // --- FORM & USER INPUT ---
                async handleFormSubmit(e) {
                    e.preventDefault();
                    const userText = this.elements.userInput.value.trim();
                    if (userText && !this.elements.userInput.disabled) {
                        this.addMessage(userText, 'user-message');
                        this.updateHistory("user", userText);
                        this.elements.userInput.value = '';
                        this.setFormState(true);
                        this.toggleTypingIndicator(true);
                        
                        try {
                            const botText = await this.getBotResponse();
                            this.updateHistory("model", botText);
                            this.toggleTypingIndicator(false);
                            this.addBotMessage(botText);
                        } catch (error) {
                            this.toggleTypingIndicator(false);
                            this.addBotMessage("My apologies, but I've encountered a network error. Please try again shortly.");
                            this.setFormState(false);
                        }
                    }
                },

                setFormState(disabled) {
                    this.elements.userInput.disabled = disabled;
                    this.elements.sendBtn.disabled = disabled;
                    if (!disabled) this.elements.userInput.focus();
                },
                
                // --- API & DATA ---
                updateHistory(role, text) {
                    this.conversationHistory.push({ role, parts: [{ text }] });
                },

                async getBotResponse() {
                    try {
                        const response = await fetch(this.API_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ contents: this.conversationHistory })
                        });
                        if (!response.ok) throw new Error(`API error: ${response.status}`);
                        const data = await response.json();
                        return data.candidates[0].content.parts[0].text;
                    } catch (error) {
                        console.error("Failed to get bot response:", error);
                        this.conversationHistory.pop(); // Remove user message from history on failure
                        throw error;
                    }
                },
                
                // --- SCROLL HANDLING ---
                handleScroll() {
                    const el = this.elements.chatBox;
                    const atBottom = el.scrollHeight - el.clientHeight <= el.scrollTop + 20;
                    this.isUserScrolledUp = !atBottom;
                    
                    if (this.isUserScrolledUp && !this.isBotTyping) {
                        this.elements.scrollDownBtn.classList.add('visible');
                    } else {
                        this.elements.scrollDownBtn.classList.remove('visible');
                    }
                },

                scrollToBottom(smooth = true) {
                    this.elements.chatBox.scrollTo({ 
                        top: this.elements.chatBox.scrollHeight, 
                        behavior: smooth ? 'smooth' : 'auto' 
                    });
                },
            };
            
            chatApp.init();
        });
    </script>
</body>
</html>
